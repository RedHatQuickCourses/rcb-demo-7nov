#  Executing Ad-hoc Commands on Remote Hosts

= Executing Ad-hoc Commands on Remote Hosts

In the previous lab, you set up an Ansible Control Node and configured Managed Hosts. Now, it's time to put Ansible to work by executing your first commands on these remote systems. This section introduces you to Ansible ad-hoc commands, which are perfect for performing quick, one-off tasks across your infrastructure.

== What are Ansible Ad-hoc Commands?

Ansible ad-hoc commands are simple, single-task commands executed directly from the command line on your Ansible Control Node, targeting one or more Managed Hosts. They are designed for quick tasks that don't require the persistent, structured automation that Ansible playbooks provide. Think of them as executing a single shell command or using a specific Ansible module *just once* to achieve an immediate result.

*   *Contrast with Playbooks*:
    *   *Ad-hoc commands* are for immediate, single-purpose operations (e.g., rebooting a server, checking disk space, installing a single package). They are quick and simple.
    *   *Playbooks* are for complex, multi-step, repeatable automation, configuration management, and orchestration (e.g., deploying a multi-tier application, configuring an entire web server stack). They are declarative, version-controlled, and designed for consistency.

*   *Common Use Cases for Ad-hoc Commands*:
    *   **Checking Connectivity**: Verifying that Ansible can reach and authenticate with your Managed Hosts.
    *   **Gathering Information**: Quickly collecting facts about your systems (e.g., OS version, IP addresses, disk usage).
    *   **Managing Packages**: Installing, upgrading, or removing software packages on multiple hosts.
    *   **Managing Services**: Starting, stopping, or restarting services across your servers.
    *   **Running Arbitrary Commands**: Executing shell commands or scripts on remote machines.
    *   **User Management**: Creating or deleting users.
    *   **File Management**: Copying files, changing permissions, or deleting files.

== The `ansible` Command Syntax

The general syntax for running an ad-hoc command using the `ansible` command-line tool is:

```bash
ansible <pattern> -m <module> -a "<module_arguments>" [options]
```

Let's break down each component:

*   `ansible`: This is the main command-line utility for running ad-hoc commands.
*   `<pattern>`: This specifies which hosts or groups from your inventory file you want to target.
    *   `all`: Targets all hosts in your inventory.
    *   `webservers`: Targets all hosts in the `webservers` group.
    *   `host1,host2`: Targets specific hosts by name.
    *   `webservers:&dbservers`: Targets hosts that are in both the `webservers` AND `dbservers` groups.
    *   `webservers:!dbservers`: Targets hosts in the `webservers` group but NOT in the `dbservers` group.
*   `-m <module>`: This flag specifies the Ansible module you want to use. Modules are reusable units of code that Ansible executes on the Managed Hosts. Ansible comes with hundreds of built-in modules for various tasks.
    *   Examples: `ping`, `command`, `shell`, `apt`, `yum`, `service`, `copy`, `file`, `user`, `setup`.
*   `-a "<module_arguments>"`: This flag passes arguments to the specified module. The arguments are specific to each module and should be enclosed in double quotes.
*   `[options]`: These are optional flags that modify the command's behavior:
    *   `-i <inventory_file>`: Specifies an alternative inventory file if you're not using the default (`/etc/ansible/hosts` or `~/.ansible/hosts`).
    *   `-u <remote_user>`: Specifies the user to connect as on the Managed Hosts. If not specified, Ansible uses the current user on the Control Node or the `remote_user` defined in `ansible.cfg`.
    *   `--become` or `-b`: Enables privilege escalation (e.g., `sudo`) on the Managed Hosts to run commands as root or another user.
    *   `--ask-become-pass` or `-K`: Prompts for the `sudo` password on the Managed Hosts.
    *   `--ask-pass` or `-k`: Prompts for the SSH password to connect to the Managed Hosts. Useful if you're not using SSH keys.
    *   `-f <forks>` or `--forks <forks>`: Specifies the number of parallel processes to use (default is 5).
    *   `-v`, `-vv`, `-vvv`, `-vvvv`: Increases verbosity of output for debugging.

[[_hands_on_ad_hoc]]
== Hands-on Lab: Executing Ad-hoc Commands

In this lab, you will practice running various ad-hoc commands to interact with your Managed Hosts. Ensure your Ansible Control Node and Managed Hosts are running and properly configured as per the previous lab.

=== Prerequisites

*   An Ansible Control Node with Ansible installed.
*   At least one Managed Host reachable via SSH from the Control Node.
*   Your `inventory` file (e.g., `~/ansible-inventory/inventory.ini`) is correctly configured and contains your Managed Hosts.
*   SSH keys are set up for passwordless access, or you are prepared to provide passwords when prompted.

=== Activity 1: Testing Connectivity with the `ping` module

The `ping` module is the simplest way to test if Ansible can connect to your Managed Hosts, authenticate, and run a basic command. It doesn't use ICMP ping; instead, it tests the Ansible connection itself.

. On your Ansible Control Node, execute the following command to `ping` all hosts in your inventory:
+
```bash
ansible all -m ping -i ~/ansible-inventory/inventory.ini
```
+
[NOTE]
The `-i ~/ansible-inventory/inventory.ini` flag ensures Ansible uses your specific inventory file. If you have configured Ansible to use this inventory file by default (e.g., via `ansible.cfg` or by placing it in `/etc/ansible/hosts`), you can omit this flag. For this lab, we'll explicitly include it for clarity.

. *Expected Output*:
+
```
managed-host-1 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
managed-host-2 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
```
+
If you see `SUCCESS => {"ping": "pong"}`, it means Ansible successfully connected and executed the module on the Managed Host. If you see `UNREACHABLE` or `FAILED`, double-check your SSH connectivity, user permissions, and inventory file.

=== Activity 2: Running Shell Commands with `command` and `shell` modules

The `command` and `shell` modules allow you to execute arbitrary commands on your Managed Hosts.

*   The `command` module is simpler and safer. It *does not* process variables, pipes, or redirects. It's best for basic commands like `ls`, `df`, `uptime`.
*   The `shell` module is more powerful. It executes commands through a shell (like `bash`), allowing you to use shell features like pipes (`|`), redirects (`>`), environment variables, and more. Use `shell` when `command` isn't sufficient.

. Use the `command` module to check the uptime of your Managed Hosts:
+
```bash
ansible all -m command -a "uptime" -i ~/ansible-inventory/inventory.ini
```

. *Expected Output*:
+
```
managed-host-1 | CHANGED | rc=0 >>
 09:30:00 up 1 day, 2:34,  1 user,  load average: 0.00, 0.01, 0.05
managed-host-2 | CHANGED | rc=0 >>
 09:30:00 up 1 day, 2:34,  1 user,  load average: 0.00, 0.01, 0.05
```
+
[NOTE]
The `CHANGED | rc=0` indicates that the command was executed successfully (return code 0). The `>>` signifies the standard output of the command.

. Use the `shell` module to list the contents of `/var/log` and count the number of lines. This demonstrates using a pipe (`|`).
+
```bash
ansible all -m shell -a "ls -l /var/log | wc -l" -i ~/ansible-inventory/inventory.ini
```

. *Expected Output*:
+
```
managed-host-1 | CHANGED | rc=0 >>
42
managed-host-2 | CHANGED | rc=0 >>
38
```

=== Activity 3: Managing Packages with `apt` or `yum` (Requires Privilege Escalation)

Ansible provides modules to manage packages specific to the operating system's package manager (e.g., `apt` for Debian/Ubuntu, `yum` for CentOS/RHEL, `dnf` for Fedora/RHEL8+). Package management typically requires root privileges, so you'll need to use the `--become` flag.

First, identify the package manager for your Managed Hosts. For this lab, we'll assume Ubuntu/Debian, using the `apt` module. If your hosts are CentOS/RHEL, use `yum` instead.

. *Install a package (e.g., `nginx` for webservers) using `apt` with `--become`*:
+
```bash
ansible managed-host-1 -m apt -a "name=nginx state=present" --become -i ~/ansible-inventory/inventory.ini
```
+
[NOTE]
If your `sudo` user on the Managed Host requires a password, you'll also need to add `--ask-become-pass` or `-K` to the command.

. *Expected Output*:
+
You should see output indicating that `nginx` was installed or is already at the latest version. The `changed=true` or `changed=false` status will reflect this.
+
```
managed-host-1 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "cache_update_time": 1701234567,
    "cache_updated": true,
    "changed": true,
    "msg": "All requested packages are already installed.",
    "package": "nginx",
    "state": "present",
    "stderr": "",
    "stderr_lines": [],
    "stdout": "N: Download is performed unauthenticated because the user is not in the trusted 'apt:trusted' group (not the root user).\n",
    "stdout_lines": [
        "N: Download is performed unauthenticated because the user is not in the trusted 'apt:trusted' group (not the root user)."
    ]
}
```

. *Verify `nginx` installation (optional)*:
+
```bash
ansible managed-host-1 -m command -a "dpkg -l | grep nginx" -i ~/ansible-inventory/inventory.ini
```

. *Remove the package using `apt` with `--become`*:
+
```bash
ansible managed-host-1 -m apt -a "name=nginx state=absent" --become -i ~/ansible-inventory/inventory.ini
```

=== Activity 4: Managing Services with the `service` module

The `service` module is used to start, stop, restart, enable, or disable system services (e.g., `nginx`, `apache2`, `sshd`). It also typically requires privilege escalation.

. *Install `nginx` again on `managed-host-1` to have a service to manage:*
+
```bash
ansible managed-host-1 -m apt -a "name=nginx state=present" --become -i ~/ansible-inventory/inventory.ini
```

. *Start and enable the `nginx` service on `managed-host-1`*:
+
```bash
ansible managed-host-1 -m service -a "name=nginx state=started enabled=yes" --become -i ~/ansible-inventory/inventory.ini
```
+
* `state=started`: Ensures the service is running.
* `enabled=yes`: Configures the service to start automatically on boot.

. *Expected Output*:
+
```
managed-host-1 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": true,
    "name": "nginx",
    "state": "started"
}
```

. *Check the status of the `nginx` service*:
+
```bash
ansible managed-host-1 -m command -a "systemctl status nginx" -i ~/ansible-inventory/inventory.ini
```

. *Stop the `nginx` service*:
+
```bash
ansible managed-host-1 -m service -a "name=nginx state=stopped" --become -i ~/ansible-inventory/inventory.ini
```

=== Activity 5: Gathering Facts with the `setup` module

The `setup` module (also known as the "facts" module) collects detailed information about the Managed Hosts. This "fact gathering" is performed automatically by playbooks by default but can be run ad-hoc. The collected facts include network interfaces, operating system details, memory, disk usage, and much more.

. *Gather all facts from `managed-host-2`*:
+
```bash
ansible managed-host-2 -m setup -i ~/ansible-inventory/inventory.ini
```
+
This command will output a large JSON dictionary containing a vast amount of information about `managed-host-2`.

. *Filter specific facts*: Sometimes you only need a subset of facts. You can use the `filter` argument to narrow down the output. Let's find out the operating system distribution.
+
```bash
ansible managed-host-2 -m setup -a "filter=ansible_distribution*" -i ~/ansible-inventory/inventory.ini
```
+
*Expected Output*:
+
```
managed-host-2 | SUCCESS => {
    "ansible_facts": {
        "ansible_distribution": "Ubuntu",
        "ansible_distribution_file_parsed": true,
        "ansible_distribution_file_path": "/etc/os-release",
        "ansible_distribution_file_variable_major_version": "22",
        "ansible_distribution_file_variable_os_id": "ubuntu",
        "ansible_distribution_file_variable_version": "22.04",
        "ansible_distribution_major_version": "22",
        "ansible_distribution_release": "jammy",
        "ansible_distribution_version": "22.04",
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false
}
```
+
This demonstrates how powerful the `setup` module is for quickly gathering system-specific data.

=== Activity 6: Managing Files

Ansible provides modules like `copy`, `file`, `template` (for playbooks), etc., to manage files and directories on remote hosts.

. *Create a new directory `/tmp/ansible_test` on `managed-host-2`*:
+
```bash
ansible managed-host-2 -m file -a "path=/tmp/ansible_test state=directory mode=0755" --become -i ~/ansible-inventory/inventory.ini
```
+
* `path`: Specifies the directory path.
* `state=directory`: Ensures it's a directory.
* `mode=0755`: Sets the permissions.

. *Verify the directory creation*:
+
```bash
ansible managed-host-2 -m command -a "ls -ld /tmp/ansible_test" -i ~/ansible-inventory/inventory.ini
```

. *Create an empty file within the new directory*:
+
```bash
ansible managed-host-2 -m file -a "path=/tmp/ansible_test/my_test_file.txt state=touch mode=0644 owner=root group=root" --become -i ~/ansible-inventory/inventory.ini
```
+
* `state=touch`: Creates an empty file or updates its timestamp if it exists.

. *Verify the file creation*:
+
```bash
ansible managed-host-2 -m command -a "ls -l /tmp/ansible_test/my_test_file.txt" -i ~/ansible-inventory/inventory.ini
```

. *Remove the directory and its contents*:
+
```bash
ansible managed-host-2 -m file -a "path=/tmp/ansible_test state=absent" --become -i ~/ansible-inventory/inventory.ini
```
+
* `state=absent`: Ensures the path (and its contents if it's a directory) does not exist.

. *Verify the directory removal*:
+
```bash
ansible managed-host-2 -m command -a "ls -ld /tmp/ansible_test" -i ~/ansible-inventory/inventory.ini
```
+
This command should return an error indicating the file or directory does not exist, confirming its removal.

=== Activity 7: Managing Users

The `user` module allows you to create, modify, or delete users on Managed Hosts. This also typically requires privilege escalation.

. *Create a new user `ansibletestuser` on `managed-host-1`*:
+
```bash
ansible managed-host-1 -m user -a "name=ansibletestuser comment='Ansible Test User' shell=/bin/bash groups=sudo append=yes password='!'" --become -i ~/ansible-inventory/inventory.ini
```
+
* `name`: The username.
* `comment`: A descriptive comment.
* `shell`: The user's default shell.
* `groups=sudo append=yes`: Adds the user to the `sudo` group without removing them from other groups.
* `password='!'`: Sets a password that cannot be used for login directly (forces SSH key usage or external authentication). For a real password, you'd use `password='{{ "your_password_here" | password_hash("sha512") }}'`.

. *Verify the user creation*:
+
```bash
ansible managed-host-1 -m command -a "id ansibletestuser" -i ~/ansible-inventory/inventory.ini
ansible managed-host-1 -m command -a "grep ansibletestuser /etc/sudoers.d/*" --become -i ~/ansible-inventory/inventory.ini
```

. *Remove the user `ansibletestuser`*:
+
```bash
ansible managed-host-1 -m user -a "name=ansibletestuser state=absent remove=yes" --become -i ~/ansible-inventory/inventory.ini
```
+
* `state=absent`: Ensures the user does not exist.
* `remove=yes`: Removes the user's home directory and mail spool.

. *Verify the user removal*:
+
```bash
ansible managed-host-1 -m command -a "id ansibletestuser" -i ~/ansible-inventory/inventory.ini
```
+
This command should return an error indicating the user does not exist.

== Troubleshooting Ad-hoc Commands

*   *`UNREACHABLE`*:
    *   **Connectivity**: Can your Control Node SSH to the Managed Host using the specified user (`-u`)? Test with `ssh <user>@<managed_host>`.
    *   **Firewall**: Is the SSH port (22) open on the Managed Host and allowed by any network firewalls?
    *   **Inventory**: Is the hostname/IP address in your inventory file correct?
*   *`FAILED!` or `rc=1` (or other non-zero return code)*:
    *   **Permissions**: Does the remote user have the necessary permissions to execute the command or module? Use `--become` (`-b`) for privilege escalation.
    *   **Sudo Password**: If `--become` is used, does the remote user have `sudo` privileges, and if required, are you providing the `sudo` password (`--ask-become-pass` / `-K`)?
    *   **Command/Module Syntax**: Is the command or module's syntax correct? Check the Ansible documentation for the specific module.
    *   **Path**: Is the command executable available in the `PATH` of the remote user?
*   *`No such file or directory`*: The file or directory specified in your command/module arguments does not exist on the Managed Host.
*   *Verbosity*: Use `-v`, `-vv`, `-vvv`, or `-vvvv` with your `ansible` command to get more detailed output, which can help pinpoint the exact error.

Ad-hoc commands are a fundamental part of Ansible, providing a quick and efficient way to interact with your infrastructure for immediate tasks. As you become more comfortable with them, you'll find them invaluable for daily administrative operations. For more complex, repeatable, and declarative automation, you'll transition to using Ansible Playbooks, which build upon the same module concepts.